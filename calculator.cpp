#include <iostream>
#include <string>
#include <locale.h>

#include "errors.h"
#include "constans.h"
#include "Token_stream.h"
#include "Variables_stack.h"

/*
 * Calculator
 * Калькулятор, который способен вычислять сложные выражения.
 * Автор Сергей Меденцов 04.05.2023-11.05.2023
 * version 0.7
 *
 * Что добавлено в этой версии:
 *  Добавлена возможность использовать переменные.
 *
 * Какие фрагменты кода могут вызвать сложности.
 *  ???
 *
 * Основные идеи проекта.
 *  Написать простой, но эффективный калькулятор, который может решать сложные примеры,
 *   например такие: 2+3.1*4=14.4, 10*(20+30)-100=400, 1+2*3/4%5+(6-7*(8))=-47.5
 *   или такие: variable=30sky=24.5, res=variable+sky-4! res
 *
 * Как организован код.
 *  Программа выводит информацию о программе и ожидает ввода выражения,
 *   затем парсит введённую строку, разбивая её на лексемы,
 *   а затем, считывая лексемы вычисляет выражения и выводит результат выражения.
 *  Лексемы представлены классом Token и содержат вид лексемы и её значение.
 *  Работа с лексемами ложится на класс Token_stream, который парсит строку введёного выражения.
 *   Более подробно работа класса описана в заголовочном файле класса.
 *  Функции expression(), term(), primary() реализуют грамматику выражений, описанную ниже,
 *   и собственно вычисляют выражение.
 *  Ошибки описаны в заголовочном файле errors.
 *   При выбрасывании исключения программа выводит сообщение в консоль и продолжает работу.
 *
 * Какие сделаны предположения о вводных данных.
 *  Вводные данные должны быть одной строкой, содержащей цифры и знаки операторов: + - / * % ( ) . , { }
 *   Программа парсит введённую строку и разбивает её на части.
 *
 * Каких фрагментов кода пока не хватает и какие варианты ещё не обработаны.
 *  Вот следующая строка. Если ввести слово или букву, то программа добавит новую переменную. Этого нужно избежать!
 *  Так же проблема возникает, когда название переменной заканчивается на e.
 *  Плюс, при инициализации переменной экспонентой съедается одна цифра!
 * Mary had a little lamb - подумать, как обработать такую строку
 * srtvrqtiewcbet7rewaewre-wqcntrretewru754389652743nvcqnwq; - тоже проверить строку
 * 2.14748e+09 - неверный вывод. Проблема с e-экспонентой
 *   C этим выражением (F - 32) / 1.8 тоже возникают проблемы! Перепроверить.
 *  Очень много глобальных переменных. Как это решить?
 *  А так же тогда уж можно добавить и вычисление математических функций.
 *  Готовое решение формул!
 *  Ещё можно выводить циклы!
 *  Операторы сравнения тоже можно реализовать.
 *  Если просто нажать Enter можно выводить какую-нибудь интересную информацию)
*/
/*
* РАЗМЫШЛЕНИЯ НАД ЗАДАЧЕЙ:
*  Добавление в программу переменных.
*  ---------------------------------
*
*
 * x=13
 * res=10+50
 * variable=30sky=24.5
 * res=variable+sky-4!
 * res
 * ex=5
 * ex!
 * ex=2.14748e+09
*          /|\/|\/|\
*           |  |  |
* Судя по этим данным переменные должны читаться так же, как и любое выражение, как обычное число.
*
*   Можно создать класс переменных, на подобие класса Token, которое будет содержать название переменной и её значение. Назовём его Variables
*    Переменные сохраняются в класс Variables и доступны всё время работы программы. Можно объявить сколько угодно переменных, так же можно менять их значение.
*     Это означает, что программа должна проверять, существует ли уже переменная и если существует, то должна её переназначить.
*    Использование переменных:
*     При парсинге выражений класс Token_stream должен помещать в лексемы значения переменных.
* - Краткое изложение идеи, лежащей в основе решения.
* - Найти изъяны в своей первой идее.
* - Обсудить задачу и способы её решения с друзьями.
*/

/***********************************************************************************************************************************************/
// ПРОТОТИПЫ ФУНКЦИЙ
void   help();
void   calculate();
//-------------------------------------------------------
double initial();
double expression();
double term();
double primary();
unsigned long int factorial(unsigned long int value);
/***********************************************************************************************************************************************/

Token_stream ts;
Variables_stack vs;

int main() {
	setlocale(LC_ALL, "Russian");

	help();

	calculate();

	return 0;
}

/***********************************************************************************************************************************************/
// Описание работы программы.
void help() {
	std::cout << TITLE << ". version " << VERSION << std::endl;
	std::cout << "________________________________________________________________________________________________________________________" << std::endl;
	std::cout << "Вы можете ввести любое выражение, используя операторы [+][-][*][/]. Для получения ответа введите [Enter]." << std::endl;
	std::cout << "Так же можно использовать скобки [(][)][{][}] для указания порядка вычисления. Скобки идентичны, но не взаимозаменяемы!" << std::endl;
	std::cout << "Оператор [%] используется для вычисления остатка от деления." << std::endl;
	std::cout << "Оператор [" << FACTORIAL << "] используется для вычисления факториала и указывается после числа, факториал которого необходимо вычислить." << std::endl;
	std::cout << "Введите  [" << EXIT << "] для выхода из программы." << std::endl;
	std::cout << "________________________________________________________________________________________________________________________" << std::endl;
}
// ПОЛУЧЕНИЕ ВВОДНЫХ ДАННЫХ и Вызов функций обработчиков.
void calculate() {
	while (true) {
		try {
			std::string input;
			std::cout << "\n" << INPUT;
			getline(std::cin, input);
			if (*input.c_str() == EXIT) break;
			if (input == "") {
				std::cout << "Здесь будет интересная информация!\n";
				continue;
			}
			if (!std::cin) throw ErrorInvalidInput{};
			ts.parsing(input, vs);
			//ts.show_tokens();
			//std::cout << RESULT << expression() << std::endl;
			std::cout << RESULT << initial() << std::endl;
		}
		catch (ErrorUnknownToken)        { std::cerr << "ОШИБКА! Неизвестная лексема!\n"; }
		catch (ErrorInvalidInput)        { std::cerr << "ОШИБКА! Неверный ввод выражения!\n"; }
		catch (ErrorMissingRightBracket) { std::cerr << "ОШИБКА! Нет закрывающей скобки!\n"; }
		catch (ErrorMissingLeftBracket)  { std::cerr << "ОШИБКА! Нет открывающей скобки!\n"; }
		catch (ErrorNegativeFactorial)   { std::cerr << "ОШИБКА! Отрицательный факториал!\n"; }
		catch (ErrorOverflowValue)       { std::cerr << "ОШИБКА! Переполнение значения факториала!\n"; }
		catch (ErrorNoLeftExpression)    { std::cerr << "ОШИБКА! Нет начального значения!\n"; }
		catch (ErrorDivisionZero)        { std::cerr << "ОШИБКА! Деление на ноль!\n"; }
		catch (ErrorNoVariable)          { std::cerr << "ОШИБКА! Переменная не определена!\n"; }
	}
}
/***********************************************************************************************************************************************/

/***********************************************************************************************************************************************/
// ФУНКЦИИ, РЕАЛИЗУЮЩИЕ ГРАММАТИКУ ВЫРАЖЕНИЙ

/*	ГРАММАТИКА ВЫРАЖЕНИЙ:
* --------------------------------------------------------------------
* Инициализация:
*   Переменная "=" Выражение
* Выражение:
*	Терм
*	Выражение "+" Терм	// Сложение
*	Выражение "-" Терм	// Вычитание
* Терм:
*	Первичное_выражение
*	Первичное_выражение!			// Факториал
*	Терм "*" Первичное_выражение	// Умножение
*	Терм "/" Первичное_выражение	// Деление
*	Терм "%" Первичное_выражение	// Остаток (деление по модулю)
* Первичное_выражение:
*   Переменная
*	Число
*   -Число
*   +Число
*	"(" Выражение ")"	// Группировка
* Переменная:
*   строковый_литерал
* Число:
*	Литерал_с_плавающей_точкой
*/
double initial() {
	Token t = ts.get();
	if (t.kind == EXIT) {
		return vs.get_last_number();
	}
	if (t.kind == VARIABLE) {
		int index = t.value;
		t = ts.get();
		if (t.kind == INITIAL) {
			double d = expression();
			vs.add_variable(vs.get_name(index), d);
			ts.putback();
			return initial();
		}
		else {
			return vs.get_variable(index);
		}
	}
	else {
		ts.putback();
		return expression();
	}
}
// Функция проверяет, является ли лексема выражением.
// И работает с операторами '+' и '-'.
double expression() {
	double left = term();
	Token t;
	while (true) {
		t = ts.get();
		switch (t.kind) {
		case '+':
			left += term();
			break;
		case '-':
			left -= term();
			break;
		default:
			return left;
		}
	}
}
// Функция проверяет, является ли лексема термом.
// И работает с операторами '*', '/', '%'
double term() {
	double left = primary();
	Token t;
	while (true) {
		t = ts.get();
		switch (t.kind) {
		case '*':
			left *= primary();
			break;
		case '/':
		{
			double p = primary();
			if (p == 0) {
				ts.get();
				throw ErrorDivisionZero{};
			}
			left /= p;
			break;
		}
		case '%':
		{
			double p = primary();
			if (p == 0) {
				ts.get();
				throw ErrorDivisionZero{};
			}
			double res = (int)left / (int)p;
			left = left - (res * p);
			break;
		}
		case FACTORIAL:
			return factorial(left);
		default:
			ts.putback();	// Возвращаемся на предыдущую лексему
			return left;
		}
	}
}
// Функция проверяет, является ли лексема первичным выражением.
double primary() {
	Token t = ts.get();
	switch (t.kind) {
	case NUMBER:	// Число
	{
		return t.value;
	}
	case VARIABLE:
	{
		int index = t.value;
		return vs.get_variable(index);
	}
	case '-':
		return -primary();
	case '+':
		return primary();
	case '(':	// Выражение в скобках
	case '{':
	{
		double d = expression();
		ts.putback();
		t = ts.get();
		if (t.kind != ')' && t.kind != '}') throw ErrorMissingRightBracket{};
		else {
			t = ts.get();
			if (t.kind == FACTORIAL) {
				return factorial(d);
			}
			else ts.putback();
		}
		return d;
	}
	default:	// Возвращаемся на предыдущую лексему
		throw ErrorInvalidInput{};
	}
}
// Факториал
unsigned long int factorial(unsigned long int value) {
	if (value == 0) return 1;
	if (value < 0) throw ErrorNegativeFactorial{};
	for (int count = value; count > 1;) {
		value *= --count;
	}
	if (value <= 0) throw ErrorOverflowValue{};
	return value;
}
/***********************************************************************************************************************************************/



/*

Variables_stream vs;

*/

/*
	std::cout << "Вы можете использовать любые английские буквы, кроме [e][" << VARIABLES << "], для создания переменной.Пример: a " << INITIAL << " 10" << std::endl;
	std::cout << "А после использовать переменную в выражениях: a+40: " << RESULT << "50. 110 - a: " << RESULT << "100." << std::endl;
	std::cout << "Введите  [" << SHOWVARS << "] для просмотра всех определённых переменных и их значений." << std::endl;


			if (ts.get_declaration()) {
				ts.set_declaration(false);
				continue;
			}
			if (*input.c_str() == SHOWVARS) {
				continue;
			}
*/

/* TESTS
1+2+3+4+5+6+7+8			// 36
1-2-3-4					// -8
!+2						// err
(1+3					// err
(1+)					// err
1*2/3%4+5-6				// -0.333333
()						// err
1+						// err
+1						// 1
1/0						// err
1++2					// 3
-2						// -2
1234567890123456		// 1.23457e+15
'a'						// err
1+#						// err
1+2 #					// err
Mary had a little lamb	// err
srtvrqtiewcbet7rewaewre-wqcntrretewru754389652743nvcqnwq;
!@#$%^&*()~:;
2.14748e+09				// 2.14748e+09
x=13
x						// 13
res=10+50
res						// 60
var=30sky=24
variable=30file=24.5
res=variable+file-4!
res						// 30.5
ex=5
ex!						// 120
ex=2.14748e+09
ex						// 2.14748e+09
var1=10
var2=20
var1
#
*/