#include <iostream>
#include <string>
#include <vector>
#include <locale.h>

#include "errors.h"
#include "Token.h"
#include "Token_stream.h"

/*
 * Calculator
 * Калькулятор, который способен вычислять сложные выражения.
 * Автор Сергей Меденцов 26.04.2023
 * version 0.6.3
 * 
 * Что добавлено в этой версии:
 *  Добавлено вычисление факториала.
 *
 * Какие фрагменты кода могут вызвать сложности.
 *  ???
 * 
 * Основные идеи проекта.
 *  Написать простой, но эффективный калькулятор, который может решать сложные примеры,
 *   например такие: 2+3.1*4=14.4, 10*(20+30)-100=400, 1+2*3/4%5+(6-7*(8))=-47.5
 * 
 * Как организован код.
 *  Программа ожидает ввода выражения, затем парсит введённую строку, разбивая её на лексемы, 
 *   а затем, считывая лексемы вычисляет выражения и выводит результат выражения.
 *  Лексемы представлены классом Token и содержат вид лексемы и её значение.
 *  Работа с лексемами ложится на класс Token_stream, который парсит строку введёного выражения.
 *   Более подробно работа класса описана в заголовочном файле класса.
 *  Функции expression(), term(), primary() реализуют грамматику выражений, описанную ниже,
 *   и собственно вычисляют выражение.
 *  Ошибки описаны в заголовочном файле errors. 
 *   При выбрасывании исключения программа выводит сообщение в консоль и продолжает работу.
 *  
 * Какие сделаны предположения о вводных данных.
 *  Вводные данные должны быть одной строкой, содержащей цифры и знаки операторов: + - / * % ( ) . ,
 *   Программа парсит введённую строку и разбивает её на части.
 * 
 * Каких фрагментов кода пока не хватает и какие варианты ещё не обработаны.
 *  Проблема с числами меньше ноля! Программа пока не умеет их решать.
 *  Также не реализовано чтение лексемы в экспоненциальном представлении.
 *  Интересная идея добавить в калькулятор переменные m = 9; v = 7; v * m;
 *  А так же тогда уж можно добавить и вычисление математических функций.
 *  Ещё можно выводить циклы!
*/
/*
* РАЗМЫШЛЕНИЯ НАД ЗАДАЧЕЙ:
* - Краткое изложение идеи, лежащей в основе решения.
* - Найти изъяны в своей первой идее.
* - Обсудить задачу и способы её решения с друзьями.
*/

double expression();
double term();
double primary();

Token_stream ts;

int main() {
	setlocale(LC_ALL, "Russian");

	std::string input;

	while (true) {
		try {
			std::cout << "Выражение: ";
			getline(std::cin, input);
			if (!std::cin) throw ErrorInvalidInput{};
			ts.parsing(input);
			std::cout << "Ответ: " << expression() << std::endl;
		}
		catch (ErrorUnknownToken) {
			std::cerr << "ОШИБКА! Неизвестная лексема!\n";
		}
		catch (ErrorDivisionZero) {
			std::cerr << "ОШИБКА! Деление на ноль!\n";
		}
		catch (ErrorInvalidInput) {
			std::cerr << "ОШИБКА! Неверный ввод выражения!\n";
		}
		catch (ErrorMissingRightBracket) {
			std::cerr << "ОШИБКА! Нет закрывающей скобки!\n";
		}
		catch (ErrorMissingLeftBracket) {
			std::cerr << "ОШИБКА! Нет открывающей скобки!\n";
		}
		catch (ErrorNegativeFactorial) {
			std::cerr << "ОШИБКА! Отрицательный факториал!\n";
		}
	}

	return 0;
}

/*********************************************************************
*	ГРАММАТИКА ВЫРАЖЕНИЙ:
* --------------------------------------------------------------------
* Выражение:
*	Терм
*	Выражение "+" Терм	// Сложение
*	Выражение "-" Терм	// Вычитание
* Терм:
*	Первичное_выражение
*	Терм "*" Первичное_выражение	// Умножение
*	Терм "/" Первичное_выражение	// Деление
*	Терм "%" Первичное_выражение	// Остаток (деление по модулю)
* Первичное_выражение:
*	Число!	// Факториал
*	Число
*	"(" Выражение ")"	// Группировка
* Число:
*	Литерал_с_плавающей_точкой
**********************************************************************/

 /********************************************/
/* ФУНКЦИИ, РЕАЛИЗУЮЩИЕ ГРАММАТИКУ ВЫРАЖЕНИЙ*/
// Функция проверяет, является ли лексема выражением.
// И работает с операторами '+' и '-'.
double expression() {
	double left = term();
	Token t;
	while (true) {
		t = ts.get();
		switch (t.kind) {
		case '+':
			left += term();
			break;
		case '-':
			left -= term();
			break;
		default:
			return left;
		}
	}
}
// Функция проверяет, является ли лексема термом.
// И работает с операторами '*', '/', '%'
double term() {
	double left = primary();
	Token t;
	while (true) {
		t = ts.get();
		switch (t.kind) {
		case '*':
			left *= primary();
			break;
		case '/':
		{
			double p = primary();
			if (p == 0) {
				throw ErrorDivisionZero{};
			}
			left /= p;
			break;
		}
		case '%':
		{
			double p = primary();
			double res = (int)left / (int)p;
			left = left - (res * p);
			break;
		}
		default:
			ts.putback();	// Возвращаемся на предыдущую лексему
			return left;
		}
	}
}
// Функция проверяет, является ли лексема первичным выражением.
double primary() {
	Token t = ts.get();
	switch (t.kind) {
	case '8':	// Число
	{
		double val = t.value;
		t = ts.get();		
		if (t.kind == '!') // Факториал
		{
			return factorial(val);
		}
		else {
			ts.putback();
			return val;
		}
	}
	case '|':	// Отрицательное число
		return 0 - t.value;
	case '(':	// Выражение в скобках
	case '{':
	{
		double d = expression();
		ts.putback();
		t = ts.get();
		if (t.kind != ')' && t.kind != '}') throw ErrorMissingRightBracket{};
		return d;
	}
	default:	// Возвращаемся на предыдущую лексему
		ts.putback();
	}
}
// Факториал
unsigned long int factorial(unsigned long int value) {
	if (value == 0) return 1;
	if (value < 0) throw ErrorNegativeFactorial{};
	for (int count = value; count > 1;) {
		value *= --count;
	}
	return value;
}

 /* ФУНКЦИИ, РЕАЛИЗУЮЩИЕ ГРАММАТИКУ ВЫРАЖЕНИЙ*/
/********************************************/