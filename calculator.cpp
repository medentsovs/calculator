#include <iostream>
#include <string>
#include <vector>
#include <locale.h>

#include "errors.h"
#include "constants.h"
#include "Token.h"
#include "Token_stream.h"

/*
*  ПРОЕКТ СТАЛ ЗАПУТАННЫМ. НУЖНО ПЕРЕПИСАТЬ И РАЗЛОЖИТЬ ВСЁ ПО ПОЛОЧКАМ!
 * Calculator
 * Калькулятор, который способен вычислять сложные выражения.
 * Автор Сергей Меденцов 30.04.2023-03.05.2023
 * version 0.6.5
 * 
 * Что добавлено в этой версии:
 *  Добавлена возможность использовать переменные.
 *
 * Какие фрагменты кода могут вызвать сложности.
 *  ???
 * 
 * Основные идеи проекта.
 *  Написать простой, но эффективный калькулятор, который может решать сложные примеры,
 *   например такие: 2+3.1*4=14.4, 10*(20+30)-100=400, 1+2*3/4%5+(6-7*(8))=-47.5
 * 
 * Как организован код.
 *  Программа ожидает ввода выражения, затем парсит введённую строку, разбивая её на лексемы, 
 *   а затем, считывая лексемы вычисляет выражения и выводит результат выражения.
 *  Лексемы представлены классом Token и содержат вид лексемы и её значение.
 *  Работа с лексемами ложится на класс Token_stream, который парсит строку введёного выражения.
 *   Более подробно работа класса описана в заголовочном файле класса.
 *  Функции expression(), term(), primary() реализуют грамматику выражений, описанную ниже,
 *   и собственно вычисляют выражение.
 *  Ошибки описаны в заголовочном файле errors. 
 *   При выбрасывании исключения программа выводит сообщение в консоль и продолжает работу.
 *  
 * Какие сделаны предположения о вводных данных.
 *  Вводные данные должны быть одной строкой, содержащей цифры и знаки операторов: + - / * % ( ) . ,
 *   Программа парсит введённую строку и разбивает её на части.
 * 
 * Каких фрагментов кода пока не хватает и какие варианты ещё не обработаны.
 *  Работа с переменными реализована отвратительно! Нужно пересмотреть код добавления и чтения переменных.
 *  Проблема, когда пытаешься назвать переменную длинным именем, а так же сделать возможность объявлять несколько переменных в одной строке.
 *   C этим выражением (F - 32) / 1.8 тоже возникают проблемы! Перепроверить.
 *  Очень много глобальных переменных. Как это решить?
 *  А так же тогда уж можно добавить и вычисление математических функций.
 *  Готовое решение формул!
 *  Ещё можно выводить циклы!
 *  Операторы сравнения тоже можно реализовать.
 *  Если просто нажать Enter можно выводить какую-нибудь интересную информацию)
*/
/*
* РАЗМЫШЛЕНИЯ НАД ЗАДАЧЕЙ:
*  +Добавление в программу переменных.
*   Можно создать класс переменных, на подобие класса Token, которое будет содержать название переменной и её значение. Назовём его Variables
*   Чтобы программа распознала переменную они должны начинаться со знака $, как в PHP.
*    Всё что идёт слитно со знаком "$" до знака "=" - это название переменной, а всё что после знака "=" - это значение переменной.
*    Парсить строку и добавлять переменные в класс Variables будет класс Token_stream. Нужно пересмотреть грамматику.
*    Переменные сохраняются в класс Variables и доступны всё время работы программы. Можно объявить сколько угодно переменных, так же можно менять их значение.
*     Это означает, что программа должна проверять, существует ли уже переменная и если существует, то должна её переназначить.
*    Использование переменных:
*     При парсинге выражений класс Token_stream должен помещать в лексемы значения переменных.
* - Краткое изложение идеи, лежащей в основе решения.
* - Найти изъяны в своей первой идее.
* - Обсудить задачу и способы её решения с друзьями.
*/

Token_stream ts;
Variables_stream vs;

int main() {
	setlocale(LC_ALL, "Russian");

	help();
	calculate();

	return 0;
}

/*********************************************************************
*	ГРАММАТИКА ВЫРАЖЕНИЙ:
* --------------------------------------------------------------------
* Выражение:
*	Терм
*	Выражение "+" Терм	// Сложение
*	Выражение "-" Терм	// Вычитание
* Терм:
*	Первичное_выражение
*	Терм "*" Первичное_выражение	// Умножение
*	Терм "/" Первичное_выражение	// Деление
*	Терм "%" Первичное_выражение	// Остаток (деление по модулю)
* Первичное_выражение:
*	Число!	// Факториал
*	Число
*   -Число
*   +Число
*	"(" Выражение ")"	// Группировка
*	"(" Выражение ")"! // Факториал выражения
* Число:
*	Литерал_с_плавающей_точкой
**********************************************************************/

 /********************************************/
/* ФУНКЦИИ, РЕАЛИЗУЮЩИЕ ГРАММАТИКУ ВЫРАЖЕНИЙ*/
// Функция проверяет, является ли лексема выражением.
// И работает с операторами '+' и '-'.

double expression() {
	double left = term();
	Token t;
	while (true) {
		t = ts.get();
		switch (t.kind) {
		case '+':
			left += term();
			break;
		case '-':
			left -= term();
			break;
		default:
			return left;
		}
	}
}
// Функция проверяет, является ли лексема термом.
// И работает с операторами '*', '/', '%'
double term() {
	double left = primary();
	Token t;
	while (true) {
		t = ts.get();
		switch (t.kind) {
		case '*':
			left *= primary();
			break;
		case '/':
		{
			double p = primary();
			if (p == 0) {
				ts.get();
				throw ErrorDivisionZero{};
			}
			left /= p;
			break;
		}
		case '%':
		{
			double p = primary();
			if (p == 0) {
				ts.get();
				throw ErrorDivisionZero{};
			}
			double res = (int)left / (int)p;
			left = left - (res * p);
			break;
		}
		default:
			ts.putback();	// Возвращаемся на предыдущую лексему
			return left;
		}
	}
}
// Функция проверяет, является ли лексема первичным выражением.
double primary() {
	Token t = ts.get();
	switch (t.kind) {
	case NUMBER:	// Число
	{
		double val = t.value;
		t = ts.get();		
		if (t.kind == FACTORIAL) // Факториал
		{
			return factorial(val);
		}
		else {
			ts.putback();
			return val;
		}
	}
	case '-':
		return - primary();
	case '+':
		return primary();
	case '(':	// Выражение в скобках
	case '{':
	{
		double d = expression();
		ts.putback();
		t = ts.get();
		if (t.kind != ')' && t.kind != '}') throw ErrorMissingRightBracket{};
		else {
			t = ts.get();
			if (t.kind == FACTORIAL) {
				return factorial(d);
			}
			else ts.putback();
		}
		return d;
	}
	default:	// Возвращаемся на предыдущую лексему
		throw ErrorInvalidInput{};
	}
}
// Факториал
unsigned long int factorial(unsigned long int value) {
	if (value == 0) return 1;
	if (value < 0) throw ErrorNegativeFactorial{};
	for (int count = value; count > 1;) {
		value *= --count;
	}
	if (value <= 0) throw ErrorOverflowValue{};
	return value;
}

 /* ФУНКЦИИ, РЕАЛИЗУЮЩИЕ ГРАММАТИКУ ВЫРАЖЕНИЙ*/
/********************************************/

void help() {
	std::cout << TITLE << ". version " << VERSION << std::endl;
	std::cout << "________________________________________________________________________________________________________________________" << std::endl;
	std::cout << "Вы можете ввести любое выражение, используя операторы [+][-][*][/]. Для получения ответа введите [Enter]." << std::endl;
	std::cout << "Так же можно использовать скобки [(][)][{][}] для указания порядка вычисления. Скобки идентичны, но не взаимозаменяемы!" << std::endl;
	std::cout << "Оператор [%] используется для вычисления остатка от деления." << std::endl;
	std::cout << "Оператор [" << FACTORIAL << "] используется для вычисления факториала и указывается после числа, факториал которого необходимо вычислить." << std::endl;
	std::cout << "Вы можете использовать любые английские буквы, кроме [e][" << VARIABLES << "], для создания переменной.Пример: a " << INITIAL << " 10" << std::endl;
	std::cout << "А после использовать переменную в выражениях: a+40: " << RESULT << "50. 110 - a: " << RESULT << "100." << std::endl;
	std::cout << "Введите  [" << VARIABLES << "] для просмотра всех определённых переменных и их значений." << std::endl;
	std::cout << "Введите  [" << EXIT << "] для выхода из программы." << std::endl;
	std::cout << "________________________________________________________________________________________________________________________" << std::endl;
}

void calculate() {
	while (true) {
		try {
			std::string input;
			std::cout << "\n" << INPUT;
			getline(std::cin, input);
			if (*input.c_str() == EXIT) break;
			if (input == "") {
				std::cout << "Здесь будет интересная информация!\n";
				continue;
			}
			if (!std::cin) throw ErrorInvalidInput{};
			ts.parsing(input);
			if (ts.get_declaration()) {
				ts.set_declaration(false);
				continue;
			}
			if (*input.c_str() == VARIABLES) {
				continue;
			}
			std::cout << RESULT << expression() << std::endl;
		}
		catch (ErrorUnknownToken) { std::cerr << "ОШИБКА! Неизвестная лексема!\n"; }
		catch (ErrorInvalidInput) { std::cerr << "ОШИБКА! Неверный ввод выражения!\n"; }
		catch (ErrorMissingRightBracket) { std::cerr << "ОШИБКА! Нет закрывающей скобки!\n"; }
		catch (ErrorMissingLeftBracket) { std::cerr << "ОШИБКА! Нет открывающей скобки!\n"; }
		catch (ErrorNegativeFactorial) { std::cerr << "ОШИБКА! Отрицательный факториал!\n"; }
		catch (ErrorOverflowValue) { std::cerr << "ОШИБКА! Переполнение значения факториала!\n"; }
		catch (ErrorNoLeftExpression) { std::cerr << "ОШИБКА! Нет начального значения!\n"; }
		catch (ErrorDivisionZero) { std::cerr << "ОШИБКА! Деление на ноль!\n"; }
		catch (ErrorNoVariable) { std::cerr << "ОШИБКА! Переменная не определена!\n"; }
	}

}


/* TESTS
1+2+3+4+5+6+7+8
1-2-3-4
!+2
(1+3
(1+)
1*2/3%4+5-6
()
1+
+1
1/0
1++2
-2
1234567890123456
'a'
1+#
1+2 #
Mary had a little lamb
srtvrqtiewcbet7rewaewre-wqcntrretewru754389652743nvcqnwq;
!@#$%^&*()~:;
2.14748e+09
#
*/